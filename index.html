<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF Processor (Band/Orchestra)</title>
  <!-- pdf.js for text extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <!-- pdf.worker.js for pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js"></script>
  <!-- pdf-lib for creating/highlighting PDF -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
</head>
<body>

  <h1>PDF Processor (Band/Orchestra)</h1>

  <label>Upload PDF: <input type="file" id="pdf-input" accept=".pdf" /></label>
  <br /><br />
  
  <label>Return Pages Containing:
    <select id="filter-type">
      <option value="both">Both (default)</option>
      <option value="band">BAND only</option>
      <option value="orchestra">ORCHESTRA only</option>
    </select>
  </label>
  <br /><br />

  <button id="process-btn" disabled>Process & Download</button>
  <div id="status"></div>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const fileInput = document.getElementById('pdf-input');
    const processBtn = document.getElementById('process-btn');
    const statusEl  = document.getElementById('status');
    const filterSel = document.getElementById('filter-type');

    let pdfArrayBuffer = null;

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files[0];
      if (file && file.type === 'application/pdf') {
        pdfArrayBuffer = await file.arrayBuffer();
        processBtn.disabled = false;
        statusEl.textContent = `Selected PDF: ${file.name}`;
      } else {
        processBtn.disabled = true;
        statusEl.textContent = 'Please select a valid PDF file.';
      }
    });

    processBtn.addEventListener('click', async () => {
      if (!pdfArrayBuffer) return;
      processBtn.disabled = true;
      statusEl.textContent = 'Processing...';

      try {
        const filterValue = filterSel.value; // 'both' | 'band' | 'orchestra'
        const matchesNeeded = [];
        if (filterValue === 'both' || filterValue === 'band') {
          matchesNeeded.push('BAND');
        }
        if (filterValue === 'both' || filterValue === 'orchestra') {
          matchesNeeded.push('ORCHESTRA');
        }

        // 1) Use PDF.js to load the PDF for text analysis
        const pdfJsDoc = await pdfjsLib.getDocument({ data: pdfArrayBuffer }).promise;
        const totalPages = pdfJsDoc.numPages;

        // 2) Create a new PDF-lib doc where we'll copy pages + highlight
        const pdfLibDoc = await PDFLib.PDFDocument.create();

        for (let pageIndex = 1; pageIndex <= totalPages; pageIndex++) {
          const page = await pdfJsDoc.getPage(pageIndex);
          const textContent = await page.getTextContent();

          // Gather text + positions. We'll keep it simple: each item in textContent.items
          // has { str, transform }. transform helps approximate position. 
          // For more robust bounding boxes, you'd parse transform in detail.
          let pageText = '';
          let foundMatchesPositions = []; 

          textContent.items.forEach(item => {
            const text = item.str;
            const tx = item.transform; 
            // tx is typically [scaleX, skewX, skewY, scaleY, offsetX, offsetY]

            // For simplicity, we'll just store the approximate top-left
            // coordinate and the item width (scaleX * text length * ~some factor)
            const textUpper = text.toUpperCase();

            matchesNeeded.forEach(term => {
              if (textUpper.includes(term)) {
                // For each occurrence, note approximate bounding box
                let startIndex = 0;
                let matchPos;
                while ((matchPos = textUpper.indexOf(term, startIndex)) !== -1) {
                  // approximate measure of the text
                  const x = tx[4] + (matchPos * (tx[0] / text.length));
                  const y = tx[5] - tx[3]; // shift downward for highlight
                  const width = term.length * (tx[0] / text.length);
                  const height = tx[3];

                  foundMatchesPositions.push({ x, y, width, height });
                  startIndex = matchPos + term.length;
                }
              }
            });

            pageText += textUpper + ' ';
          });

          // Check if page has any matches
          if (foundMatchesPositions.length > 0) {
            // 3) Copy that page from original PDF (pdf-lib can load the original PDF again or we can do one load)
            // Instead of reloading, let's keep a second arrayBuffer approach:
            // Load the original PDF with pdf-lib and copy just once. We'll do it outside the loop for performance:
            // The simplest approach is re-load once up front. Or store it statically.

            // We'll lazily load the original PDF-lib doc:
            if (!window._pdfLibOriginal) {
              window._pdfLibOriginal = await PDFLib.PDFDocument.load(pdfArrayBuffer);
            }
            // Copy the single page from the original doc
            const [copiedPage] = await pdfLibDoc.copyPages(window._pdfLibOriginal, [pageIndex - 1]);
            pdfLibDoc.addPage(copiedPage);

            // 4) Highlight the matches on that new page
            // Note that pdf-lib y-axis starts at bottom, so we might need to transform coordinates
            const { height } = copiedPage.getSize();
            foundMatchesPositions.forEach(pos => {
              copiedPage.drawRectangle({
                x: pos.x,
                // Convert PDF.js's origin to PDF-lib's origin
                y: height - pos.y - pos.height, 
                width: pos.width,
                height: pos.height,
                color: PDFLib.rgb(1, 1, 0),  // yellow
                opacity: 0.5,
              });
            });
          }
        }

        // 5) If no pages matched, show message
        if (pdfLibDoc.getPageCount() === 0) {
          statusEl.textContent = 'No pages found containing the selected term(s).';
          processBtn.disabled = false;
          return;
        }

        // 6) Final PDF in the browser
        const finalPdfBytes = await pdfLibDoc.save();
        const blob = new Blob([finalPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);

        // Create a link to download
        const link = document.createElement('a');
        link.href = url;
        link.download = 'filtered_highlighted.pdf';
        link.click(); // auto-trigger download

        URL.revokeObjectURL(url);
        statusEl.textContent = 'Done! PDF downloaded.';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error processing PDF: ' + err.message;
      }
      processBtn.disabled = false;
    });
  </script>
</body>
</html>
